<div class="lang-switcher">
  <button data-lang="ru" class="active">RU</button>
  <button data-lang="en">EN</button>
  <button data-lang="ja">JP</button>
</div>

<div class="header">
  <img src="https://line-0707.github.io/Acts/source/icon.webp" alt="Site Icon">
  <div>
    <h1><a href="https://line-0707.github.io/Acts/index.html" id="site-title">ИНФОРМАЦИОННАЯ САЙТА</a></h1>
    <h2 id="site-subtitle">Сводка опубликованных документов и ресурсов</h2>
  </div>
</div>

<div id="table-container">
  <div class="loader">Loading data from Google Sheet...</div>
</div>

<script>
  const sheetUrl = 'https://docs.google.com/spreadsheets/d/1Rvr4RwirK8-ygKXG3Qyq6Bf4OvGZ7YjsxiAb4ZI2Xeo/gviz/tq?tqx=out:csv&sheet=Лист1';

  const translations = {
    ru: {
      title: 'ИНФОРМАЦИОННАЯ САЙТА',
      subtitle: 'Сводка опубликованных документов и ресурсов',
      headers: { date: 'дата', files: 'файлы', description: 'описание' }
    },
    en: {
      title: 'INFORMATION SITE',
      subtitle: 'Summary of published documents and resources',
      headers: { date: 'date', files: 'files', description: 'description' }
    },
    ja: {
      title: '情報サイト',
      subtitle: '公開されたドキュメントとリソースの概要',
      headers: { date: '日付', files: 'ファイル', description: '説明' }
    }
  };

  let fullData = [];
  let columnIndices = {};
  let visibleHeadersInfo = [];
  // Define ALL columns that should never be displayed directly.
  const columnsToHide = new Set(['en', 'jp', 'link']);

  // Robust CSV parser to correctly handle complex data
  function parseCSV(csvText) {
    const rows = [];
    let currentRow = [];
    let currentCell = '';
    let inQuotes = false;
    csvText = csvText.replace(/\r\n/g, '\n');
    for (let i = 0; i < csvText.length; i++) {
      const char = csvText[i];
      if (inQuotes) {
        if (char === '"' && i + 1 < csvText.length && csvText[i + 1] === '"') {
          currentCell += '"';
          i++;
        } else if (char === '"') {
          inQuotes = false;
        } else {
          currentCell += char;
        }
      } else {
        if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          currentRow.push(currentCell.trim());
          currentCell = '';
        } else if (char === '\n') {
          currentRow.push(currentCell.trim());
          rows.push(currentRow);
          currentRow = [];
          currentCell = '';
        } else {
          currentCell += char;
        }
      }
    }
    if (currentCell || currentRow.length > 0) {
      currentRow.push(currentCell.trim());
      rows.push(currentRow);
    }
    return rows;
  }

  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('.lang-switcher button').forEach(button => {
      button.addEventListener('click', () => renderPage(button.dataset.lang));
    });
    fetchAndRender();
  });

  function fetchAndRender() {
    fetch(sheetUrl)
      .then(response => response.ok ? response.text() : Promise.reject('Network error'))
      .then(csvText => {
        fullData = parseCSV(csvText);
        if (fullData.length < 1) throw new Error('No data found');

        const headers = fullData[0];
        headers.forEach((header, index) => { columnIndices[header] = index; });

        // Determine which columns will be visible. 'en', 'jp', and 'link' are filtered out.
        visibleHeadersInfo = headers
          .map((header, index) => ({ header, index }))
          .filter(h => !columnsToHide.has(h.header));

        renderPage('ru'); // Render initial page in Russian
      })
      .catch(error => {
        console.error('Error:', error);
        document.getElementById('table-container').textContent = 'Error: Could not load data. Ensure the Google Sheet is "Published to the web" as a CSV.';
      });
  }

  function renderPage(lang) {
    document.getElementById('site-title').textContent = translations[lang].title;
    document.getElementById('site-subtitle').textContent = translations[lang].subtitle;
    document.documentElement.lang = lang;

    document.querySelectorAll('.lang-switcher button').forEach(button => {
      button.classList.toggle('active', button.dataset.lang === lang);
    });

    const tableContainer = document.getElementById('table-container');
    tableContainer.innerHTML = '';

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');

    const headerRow = document.createElement('tr');
    const translatedHeaders = translations[lang].headers;
    visibleHeadersInfo.forEach(({ header }) => {
      const th = document.createElement('th');
      th.textContent = translatedHeaders[header] || header;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);

    for (let i = 1; i < fullData.length; i++) {
      const rowData = fullData[i];
      if (rowData.length <= 1 && !rowData[0]) continue;

      if (rowData[0] && rowData[0].startsWith('cat[')) {
        const match = rowData[0].match(/\[(.*?)\]/);
        if (match) {
          const tr = document.createElement('tr');
          tr.className = 'category-row';
          const td = document.createElement('td');
          td.colSpan = visibleHeadersInfo.length;
          td.textContent = match[1];
          tr.appendChild(td);
          tbody.appendChild(tr);
        }
      } else {
        const tr = document.createElement('tr');
        const linkUrl = rowData[columnIndices.link];

        visibleHeadersInfo.forEach(({ header, index }) => {
          const td = document.createElement('td');
          let cellText;

          if (header === 'files') {
            if (lang === 'en') cellText = rowData[columnIndices.en];
            else if (lang === 'ja') cellText = rowData[columnIndices.jp];
            else cellText = rowData[columnIndices.files];
          } else {
            cellText = rowData[index];
          }

          cellText = cellText || '';

          if (header === 'files' && linkUrl) {
            const a = document.createElement('a');
            a.href = linkUrl;
            a.textContent = cellText;
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            td.appendChild(a);
          } else {
            td.textContent = cellText;
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }
    }

    table.appendChild(thead);
    table.appendChild(tbody);
    tableContainer.appendChild(table);
  }
</script>
</body>

</html>